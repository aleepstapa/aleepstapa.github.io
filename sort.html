<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>sprt</title>
</head>
<body>
    <h1>内排序</h1>
    <a></a>
    <h3>以随机快速排序为例</h3>
    <video src="C:\Users\kxw\Desktop\homework\neipai-rand quicksort.mp4" controls="controls" width="700px" height="400px"></video>
    <h1>外排序</h1>
    <a></a>
    <h3>归并排序</h3>
    <video src="C:\Users\kxw\Desktop\homework\waiping-guibing.mp4" controls="controls" width="700px" height="400px"></video>
    <h3>通过随机生成数据进行测试可得如下结果：</h3>
    <h4>待排序数组每隔5万取一组，随机产生十次实验，计算平均值</h4>
    <img src="C:\Users\kxw\Desktop\homework\屏幕截图 2023-11-08 091605.png" />
         <a>
             <p>
                 <h4>
                     <pre>
                  #include <time.h>
#include <stdio.h>
#include <stdlib.h>

    #define MAXINT 2147483647
    #define ARRAY 300000
    //生成多大的数组
    #define RANGE 10000000
    //产生随机数的最大值

    void BuildArray (long *p,long size){
    long i;
    srand((unsigned) time(NULL)); //用时间做种，每次产生随机数不一样
    //	printf("size=%d\t",size);
    for (i = 0; i < size; i ++){
    p[i] = (rand()*32767+rand()) % RANGE + 1;  //产生1-RANGE的随机数
    //        printf("%ld ",p[i]);
    }
    }

    void swap(long *a, long *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
    }

    void InsertionSort(long *arr, long size){
    long i, j, tmp;
    for (i = 1; i < size; i++) {
    if (arr[i] < arr[i-1]) {
    tmp = arr[i];
    for (j = i - 1; j >= 0 && arr[j] > tmp; j--) {
    arr[j+1] = arr[j];
    }
    arr[j+1] = tmp;
    }
    }
    }

    void Heapify(long *arr,long m,long size){
    long i, tmp;
    tmp = arr[m];
    for (i = 2 * m; i <= size; i *= 2) {
    if (i + 1 <= size && arr[i] < arr[i+1]) {
    i++;
    }
    if (arr[i] < tmp) {
    break;
    }
    arr[m] = arr[i];
    m = i;
    }
    arr[m] = tmp;
    }

    void Merge(long *num,long start,long mid, int end){
    long *temp = (long *)malloc((end-start+1) * sizeof(long));    //申请空间来存放两个有序区归并后的临时区域
    long i = start;
    long j = mid + 1;
    long k = 0;

    while (i <= mid && j <= end){
    if (num[i] <= num[j]){
    temp[k++] = num[i++];
    } else {
    temp[k++] = num[j++];
    }
    }

    while (i <= mid){
    temp[k++] = num[i++];
    }
    while (j <= end){
    temp[k++] = num[j++];
    }

    //将临时区域中排序后的元素，整合到原数组中
    for (i = 0; i < k; i++){
    num[start + i] = temp[i];
    }

    free(temp);
    }

    void MergeSort(long *num, long start,long end){
    long mid = start + (end - start) / 2;

    if (start >= end){
    return;
    }

    MergeSort(num, start, mid);
    MergeSort(num, mid + 1, end);

    Merge(num, start, mid, end);
    }

    void BuildHeap(long  A[],long i,long N){
    long child;
    long Tmp=A[i];

    for ( ; 2*i+1 < N; i = child){
    child = 2*i+1; 				//左孩子是2*i+1
    if (child != N - 1 && A[child + 1] > A[child])
    child++;                //找到较大的儿子节点与父亲比较
    if (Tmp < A[child])
    A[i] = A[child];
    else
    break;
    }
    A[i] = Tmp;
    }

    void HeapSort(long A[], long N){
    long i;
    for (i = N / 2; i >= 0; --i)
    BuildHeap(A, i, N); 		//构造堆
    for(i=N-1;i>0;--i){
    swap(&A[0],&A[i]);        //将最大元素（根）与数组末尾元素交换，从而删除最大元素，重新构造堆
    BuildHeap(A, 0, i);
    }
    }

    void QuickSort(long *arr, long maxlen, long begin, long end){
    long i, j;
    if (begin < end) {
    i = begin + 1;
    j = end;
    while (i < j) {
    if(arr[i] > arr[begin]){
    swap(&arr[i], &arr[j]);
    j--;
    } else {
    i++;
    }
    }
    if (arr[i] >= arr[begin]){
    i--;
    }
    swap(&arr[begin], &arr[i]);
    QuickSort(arr, maxlen, begin, i);
    QuickSort(arr, maxlen, j, end);
    }
    }

    void putout(long *arr,long size){
    for (int i=0;i< size;i++) printf("%ld\n",arr[i]);
    putchar('\n');
    }

    int main( ){
    long size = ARRAY;
    long arr[size];
    int i;
    double a[10],sum=0.0;
    clock_t start[10],end[10];
    printf("本次数据量大小为%ld,算法为归并排序:\n",size);
    for (i=0;i < 10;i++){
    BuildArray( arr, size);
    start[i] =clock();//or time(&start);
    //		InsertionSort(arr, size);
    //		HeapSort(arr, size);
    //		QuickSort(arr, size, 0, size-1);
    MergeSort(arr,0,size-1);
    end[i] =clock();
    a[i]=((double)end[i]-start[i])/CLK_TCK;
    printf("a[%d]=%.4f\n",i,a[i]);
    sum+=a[i];
    }
    printf("sum=%.4f\n",sum);
    //    putout(arr,size);
    }

</pre>
                 </h4>
             </p>
         </a>
</body>
</html>
